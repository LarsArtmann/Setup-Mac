# Dynamic Library Wrapper Template
# Advanced wrapper for non-Nix binaries with complex dynamic library dependencies
# macOS-specific implementation with DYLD library management

{ pkgs, lib }:

let
  # Advanced wrapper function for dynamic library management
  wrapWithDynamicLibs = {
    name,
    package,
    dynamicLibs ? [],
    environment ? {},
    preHook ? "",
    postHook ? "",
    installLibs ? false,
    libSearchPaths ? [],
    patchInstallNames ? true,
    sandboxProfile ? null
  }:
    let
      # Build library path from dynamic libraries and search paths
      libPath = lib.makeLibraryPath (dynamicLibs ++ lib.flatten (map (path:
        if lib.hasPrefix "/" path then [path] else
        if builtins.hasAttr path pkgs then [pkgs.${path}] else []
      ) libSearchPaths));

      # Create sandbox profile if needed
      sandboxProfileScript = if sandboxProfile != null then ''
        # Apply sandbox profile for enhanced security
        export NIX_SANDBOX_PROFILE="${sandboxProfile}"
      '' else "";

      # Install name tool patching if needed
      installNamePatching = if patchInstallNames && dynamicLibs != [] then ''
        # Patch install names for dynamic libraries
        for lib_dir in ${lib.concatStringsSep " " (map (lib: "${lib}/lib") dynamicLibs)}; do
          if [ -d "$lib_dir" ]; then
            find "$lib_dir" -name "*.dylib" -type f | while read dylib; do
              dylib_name=$(basename "$dylib")
              if [ -f "$executable_path" ]; then
                # Try to patch install names that reference system libraries
                install_name_tool -change "/usr/lib/$dylib_name" "$dylib" "$executable_path" 2>/dev/null || true
                install_name_tool -change "/System/Library/Frameworks/$dylib_name" "$dylib" "$executable_path" 2>/dev/null || true
              fi
            done
          fi
        done
      '' else "";

    in pkgs.writeShellScriptBin name ''
      # Enhanced dynamic library wrapper for ${name}
      # Generated by Setup-Mac wrapper system

      ${preHook}

      # Dynamic library path management
      export DYLD_LIBRARY_PATH="${libPath}:$DYLD_LIBRARY_PATH"

      # Framework path management (macOS-specific)
      export DYLD_FRAMEWORK_PATH="${lib.makeSearchPath "Frameworks" dynamicLibs}:$DYLD_FRAMEWORK_PATH"

      # Environment variables
      ${lib.concatStringsSep "\n" (lib.mapAttrsToList (k: v: "export ${k}=\"${v}\"") environment)}

      # Sandbox profile
      ${sandboxProfileScript}

      # Binary path detection
      executable_path="${lib.getBin package}/bin/${name}"
      if [ ! -f "$executable_path" ]; then
        # Try different binary locations
        for search_path in "${lib.getBin package}/bin/${name}" "${lib.getBin package}/${name}" "${package}/bin/${name}"; do
          if [ -f "$search_path" ]; then
            executable_path="$search_path"
            break
          fi
        done
      fi

      # Final binary existence check
      if [ ! -f "$executable_path" ]; then
        echo "Error: Binary not found for ${name} at any expected location"
        exit 1
      fi

      # Make executable if needed
      chmod +x "$executable_path" 2>/dev/null || true

      # Install name patching (if enabled)
      executable_dir=$(dirname "$executable_path")
      ${installNamePatching}

      # Install additional libraries if requested
      ${if installLibs then ''
        # Install libraries to wrapper lib directory
        wrapper_lib_dir="$HOME/.local/share/nix-wrappers/${name}/lib"
        mkdir -p "$wrapper_lib_dir"

        ${lib.concatStringsSep "\n" (map (lib: ''
          if [ -d "${lib}/lib" ]; then
            cp -r "${lib}/lib"/*.dylib "$wrapper_lib_dir/" 2>/dev/null || true
          fi
        '') dynamicLibs)}

        # Add wrapper lib directory to library path
        export DYLD_LIBRARY_PATH="$wrapper_lib_dir:$DYLD_LIBRARY_PATH"
      '' else ""}

      # Debug information (verbose mode)
      if [ "''${WRAPPER_DEBUG:-0}" = "1" ]; then
        echo "=== ${name} Wrapper Debug Information ==="
        echo "Executable: $executable_path"
        echo "DYLD_LIBRARY_PATH: $DYLD_LIBRARY_PATH"
        echo "DYLD_FRAMEWORK_PATH: $DYLD_FRAMEWORK_PATH"
        echo "Working Directory: $(pwd)"
        echo "=========================================="
      fi

      ${postHook}

      # Execute the original binary with all arguments
      exec "$executable_path" "$@"
    '';

  # Specialized wrapper for CLI tools with complex dependencies
  wrapCliTool = { name, package, ... }@args:
    wrapWithDynamicLibs (args // {
      environment = args.environment or {} // {
        # Common CLI tool environment
        TERM = "xterm-256color";
        CLICOLOR = "1";
      };
      postHook = args.postHook or "" + ''
        # CLI tool specific post-execution cleanup
        if [ $? -ne 0 ] && [ "''${WRAPPER_DEBUG:-0}" = "1" ]; then
          echo "${name} exited with error code $?"
        fi
      '';
    });

  # Specialized wrapper for GUI applications
  wrapGuiApp = { name, package, ... }@args:
    wrapWithDynamicLibs (args // {
      environment = args.environment or {} // {
        # GUI application environment
        NSDocumentRevisionsDebugMode = "YES";
      };
      preHook = args.preHook or "" + ''
        # GUI application pre-launch setup
        if [ "''${GUI_WRAPPER_DEBUG:-0}" = "1" ]; then
          echo "Launching GUI application: ${name}"
        fi
      '';
    });

  # Wrapper for downloaded binaries (non-Nix packages)
  wrapDownloadedBinary = {
    name,
    binaryPath,
    dynamicLibs ? [],
    ...
  }@args:
    let
      libPath = lib.makeLibraryPath dynamicLibs;
    in pkgs.writeShellScriptBin name ''
      # Wrapper for downloaded binary: ${name}
      # Binary location: ${binaryPath}

      # Dynamic library path
      export DYLD_LIBRARY_PATH="${libPath}:$DYLD_LIBRARY_PATH"

      # Environment setup
      ${lib.concatStringsSep "\n" (lib.mapAttrsToList (k: v: "export ${k}=\"${v}\"") (args.environment or {}))}

      # Pre-launch hook
      ${args.preHook or ""}

      # Binary existence check
      if [ ! -f "${binaryPath}" ]; then
        echo "Error: Downloaded binary not found at ${binaryPath}"
        echo "Please ensure the binary is installed and accessible"
        exit 1
      fi

      # Make executable
      chmod +x "${binaryPath}" 2>/dev/null || true

      # Execute binary
      exec "${binaryPath}" "$@"

      # Post-execution hook
      ${args.postHook or ""}
    '';

in {
  inherit
    wrapWithDynamicLibs
    wrapCliTool
    wrapGuiApp
    wrapDownloadedBinary;
}