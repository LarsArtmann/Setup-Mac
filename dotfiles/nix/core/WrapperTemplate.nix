# Wrapper Template System
# Centralized wrapper configuration to eliminate code duplication
# Provides type-safe, consistent wrapper patterns for all applications

{ lib, writeShellScriptBin, symlinkJoin, makeWrapper, ... }:

let
  # Wrapper configuration type definition
  WrapperConfigType = lib.types.submodule {
    options = {
      packageName = lib.mkOption {
        type = lib.types.str;
        description = "Name of the package being wrapped";
        example = "bat";
      };

      binaryName = lib.mkOption {
        type = lib.types.str;
        description = "Name of the binary to wrap";
        example = "bat";
      };

      package = lib.mkOption {
        type = lib.types.package;
        description = "Package to wrap";
        example = "pkgs.bat";
      };

      extraArgs = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        description = "Additional arguments to pass to the binary";
        default = [];
        example = [ "--theme=GitHub" "--style=header,numbers" ];
      };

      environmentVars = lib.mkOption {
        type = lib.types.attrsOf lib.types.str;
        description = "Environment variables to set";
        default = {};
        example = { BAT_THEME = "GitHub"; };
      };

      wrapperName = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        description = "Name for the wrapper binary (computed automatically if not provided)";
        default = null;
        example = "wrapped-bat";
      };
    };
  };

  # Core wrapper function with comprehensive type safety
  wrapWithConfig = config:
    let
      validatedConfig =
        if config ? binaryName && config ? package
        then config
        else throw "wrapWithConfig requires both binaryName and package";

      # Compute wrapper name if not provided or null
      wrapperName =
        if validatedConfig ? wrapperName && validatedConfig.wrapperName != null
        then validatedConfig.wrapperName
        else "wrapped-${validatedConfig.packageName}";

      wrapperScript = writeShellScriptBin wrapperName ''
        #!/usr/bin/env bash
        # Auto-generated wrapper for ${validatedConfig.packageName}
        # Generated by core/WrapperTemplate.nix

        # Set environment variables
        ${lib.concatStringsSep "\n" (
          lib.mapAttrsToList (key: value: "export ${key}=\"${value}\"") validatedConfig.environmentVars
        )}

        # Execute the wrapped binary with extra arguments
        exec "${validatedConfig.package}/bin/${validatedConfig.binaryName}" \
          ${lib.escapeShellArgs validatedConfig.extraArgs} "$@"
      '';

      finalWrapper = symlinkJoin {
        name = wrapperName;
        paths = [ validatedConfig.package wrapperScript ];
        buildInputs = [ makeWrapper ];
        postBuild = ''
          # Ensure wrapper is executable
          chmod +x $out/bin/${wrapperName}
        '';
      };

    in finalWrapper;

  # Specialized wrapper functions for common patterns
  createThemeWrapper = packageName: package: theme: extraArgs:
    wrapWithConfig {
      inherit packageName package;
      binaryName = packageName;
      extraArgs = [ "--theme=${theme}" ] ++ extraArgs;
      environmentVars = {
        "${lib.toUpper packageName}_THEME" = theme;
      };
    };

  createConfigWrapper = packageName: package: configPath: extraArgs:
    wrapWithConfig {
      inherit packageName package;
      binaryName = packageName;
      extraArgs = [ "--config=${configPath}" ] ++ extraArgs;
      environmentVars = {
        "${lib.toUpper packageName}_CONFIG" = configPath;
      };
    };

  createPathWrapper = packageName: package: binPath: extraArgs:
    wrapWithConfig {
      inherit packageName package;
      binaryName = packageName;
      extraArgs = [ "--bin-path=${binPath}" ] ++ extraArgs;
      environmentVars = {
        "${lib.toUpper packageName}_BIN_PATH" = binPath;
      };
    };

in {
  # Export types and core functions
  inherit WrapperConfigType wrapWithConfig;

  # Export specialized wrapper functions
  inherit createThemeWrapper createConfigWrapper createPathWrapper;

  # Helper functions for wrapper creation
  mkWrapperConfig = args: lib.types.submodule {
    options = {
      packageName = lib.mkOption { type = lib.types.str; };
      binaryName = lib.mkOption { type = lib.types.str; };
      package = lib.mkOption { type = lib.types.package; };
      extraArgs = lib.mkOption { type = lib.types.listOf lib.types.str; default = []; };
      environmentVars = lib.mkOption { type = lib.types.attrsOf lib.types.str; default = {}; };
    };
  };

  # Validation for wrapper configurations
  validateWrapperConfig = config: [
    {
      assertion = config ? packageName && config ? binaryName && config ? package;
      message = "Wrapper config requires packageName, binaryName, and package";
    }
    {
      assertion = lib.isString config.packageName && config.packageName != "";
      message = "packageName must be a non-empty string";
    }
    {
      assertion = lib.isString config.binaryName && config.binaryName != "";
      message = "binaryName must be a non-empty string";
    }
  ];
}